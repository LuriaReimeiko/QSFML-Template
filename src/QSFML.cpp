#include "QSFML.hpp"
#include <QTimer>
#include <SFML/Graphics.hpp>

QSFML::QSFML(QWidget* parent) : QWidget(parent)
{
	setAttribute(Qt::WA_NativeWindow); // Tell Qt to treat this widget as a native window
	setAttribute(Qt::WA_PaintOnScreen); // Tell Qt to not pass paint calls to its paint engine
	setAttribute(Qt::WA_OpaquePaintEvent); // Tell Qt to not clear the widget
	setAttribute(Qt::WA_NoSystemBackground); // Tell Qt to not manage the widget's background

    setAutoFillBackground(false); // Ask Qt to not fill the widget's background
    setFocusPolicy(Qt::StrongFocus); // Help SFML receive input events

    int frameLength = 8; // In MilliSeconds, 1 000 / 8 = 125fps

    // Create a Timer that will ask for Qt for a repaint on timeout, which will call paintEvent
    QTimer* timer = new QTimer(this);
    connect(timer, &QTimer::timeout, this, [this]()->void{ repaint(); });
    timer->start(frameLength); // Set the timer's length to the frameLength
}

void QSFML::resizeEvent(QResizeEvent* event)
{
    QWidget::resizeEvent(event);

    if (!initialized)
    {
        // Give SFML access to this widget
        WId wid = winId(); // Retrieve the window handle generated by Qt::WA_NativeWindow
#ifdef _WIN32
        window.create(reinterpret_cast<sf::WindowHandle>(wid));
#else
        QTimer::singleShot(5000, this, [this]
        {
            WId wid = winId();
            window.create((sf::WindowHandle)wid);
            initialized = true;
        });
#endif
        initialized = true;
    }
}

sf::RectangleShape rectShape{sf::Vector2f{15.f,15.f}};

void QSFML::paintEvent(QPaintEvent* event)
{
    Q_UNUSED(event); // Tell Qt not to manage this event

    window.clear();

    window.draw(rectShape);

    window.display();
}

QPaintEngine* QSFML::paintEngine() const
{
    return nullptr;
}
