#include "QSFML.hpp"
#include <QTimer>

QSFML::QSFML(QWidget* parent) : QWidget(parent)
{
	setAttribute(Qt::WA_NativeWindow); // Tell Qt to treat this widget as a native window
	setAttribute(Qt::WA_PaintOnScreen); // Tell Qt to not pass paint calls to its paint engine
	setAttribute(Qt::WA_OpaquePaintEvent); // Tell Qt to not clear the widget
	setAttribute(Qt::WA_NoSystemBackground); // Tell Qt to not manage the widget's background

    setAutoFillBackground(false); // Ask Qt to not fill the widget's background
    setFocusPolicy(Qt::StrongFocus); // Help SFML receive input events

    int frameLength = 8; // In MilliSeconds, 1 000 / 8 = 125fps

    // Create a Timer that will ask for Qt for a repaint on timeout, which will call paintEvent
    QTimer* timer = new QTimer(this);
    connect(timer, &QTimer::timeout, this, [this]()->void{ repaint(); });
    timer->start(frameLength); // Set the timer's length to the frameLength
}

void QSFML::showEvent(QShowEvent* event)
{
    Q_UNUSED(event); // Tell Qt not to manage this event

    if (!initialized)
    {
        // Give SFML access to this widget
        WId wid = winId(); // Retrieve the window handle generated by Qt::WA_NativeWindow
#ifdef _WIN32
        RenderWindow::create(reinterpret_cast<sf::WindowHandle>(wid));
#else
        RenderWindow::create(static_cast<sf::WindowHandle>(wid));
#endif
        initialized = true;
    }
}

void QSFML::paintEvent(QPaintEvent* event)
{
    Q_UNUSED(event); // Tell Qt not to manage this event

    RenderWindow::clear();

    RenderWindow::display();
}

QPaintEngine* QSFML::paintEngine() const
{
    return nullptr;
}
